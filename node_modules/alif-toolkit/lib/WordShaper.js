"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isArabic_1 = require("./isArabic");
var reference_1 = require("./reference");
var CharShaper_1 = require("./CharShaper");
var unicode_ligatures_1 = require("./unicode-ligatures");
function WordShaper(word) {
    var state = 'initial';
    var output = '';
    for (var w = 0; w < word.length; w++) {
        var nextLetter = ' ';
        for (var nxw = w + 1; nxw < word.length; nxw++) {
            if (!isArabic_1.isArabic(word[nxw])) {
                break;
            }
            if (reference_1.tashkeel.indexOf(word[nxw]) === -1) {
                nextLetter = word[nxw];
                break;
            }
        }
        if (!isArabic_1.isArabic(word[w]) || isArabic_1.isMath(word[w])) {
            // space or other non-Arabic
            output += word[w];
            state = 'initial';
        }
        else if (reference_1.tashkeel.indexOf(word[w]) > -1) {
            // tashkeel - add without changing state
            output += word[w];
        }
        else if ((nextLetter === ' ') // last Arabic letter in this word
            || (reference_1.lineBreakers.indexOf(word[w]) > -1)) { // the current letter is known to break lines
            output += CharShaper_1.CharShaper(word[w], state === 'initial' ? 'isolated' : 'final');
            state = 'initial';
        }
        else if (reference_1.lams.indexOf(word[w]) > -1 && reference_1.alefs.indexOf(nextLetter) > -1) {
            // LA letters - advance an additional letter after this
            output += unicode_ligatures_1.default[word[w] + nextLetter][(state === 'initial' ? 'isolated' : 'final')];
            while (word[w] !== nextLetter) {
                w++;
            }
            state = 'initial';
        }
        else {
            output += CharShaper_1.CharShaper(word[w], state);
            state = 'medial';
        }
    }
    return output;
}
exports.WordShaper = WordShaper;
