"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var unicode_arabic_1 = require("./unicode-arabic");
var unicode_ligatures_1 = require("./unicode-ligatures");
var isArabic_1 = require("./isArabic");
var reference_1 = require("./reference");
function Normal(word, breakPresentationForm) {
    // default is to turn initial/isolated/medial/final presentation form to generic
    if (typeof breakPresentationForm === 'undefined') {
        breakPresentationForm = true;
    }
    var returnable = '';
    word.split('').forEach(function (letter) {
        if (!isArabic_1.isArabic(letter)) {
            returnable += letter;
            return;
        }
        for (var w = 0; w < reference_1.letterList.length; w++) {
            // ok so we are checking this potential lettertron
            var letterForms = unicode_arabic_1.default[reference_1.letterList[w]];
            var versions = Object.keys(letterForms);
            for (var v = 0; v < versions.length; v++) {
                var localVersion = letterForms[versions[v]];
                if (typeof localVersion === 'object' && typeof localVersion.indexOf === 'undefined') {
                    // look at this embedded object
                    var embeddedForms = Object.keys(localVersion);
                    for (var ef = 0; ef < embeddedForms.length; ef++) {
                        var form = localVersion[embeddedForms[ef]];
                        if (form === letter || (typeof form === 'object' && form.indexOf && form.indexOf(letter) > -1)) {
                            // match
                            // console.log('embedded match');
                            if (form === letter) {
                                // match exact
                                if (breakPresentationForm && localVersion['normal'] && ['isolated', 'initial', 'medial', 'final'].indexOf(embeddedForms[ef]) > -1) {
                                    // replace presentation form
                                    // console.log('keeping normal form of the letter');
                                    if (typeof localVersion['normal'] === 'object') {
                                        returnable += localVersion['normal'][0];
                                    }
                                    else {
                                        returnable += localVersion['normal'];
                                    }
                                    return;
                                }
                                // console.log('keeping this letter');
                                returnable += letter;
                                return;
                            }
                            else if (typeof form === 'object' && form.indexOf && form.indexOf(letter) > -1) {
                                // match
                                returnable += form[0];
                                // console.log('added the first letter from the same array');
                                return;
                            }
                        }
                    }
                }
                else if (localVersion === letter) {
                    // match exact
                    if (breakPresentationForm && letterForms['normal'] && ['isolated', 'initial', 'medial', 'final'].indexOf(versions[v]) > -1) {
                        // replace presentation form
                        // console.log('keeping normal form of the letter');
                        if (typeof letterForms['normal'] === 'object') {
                            returnable += letterForms['normal'][0];
                        }
                        else {
                            returnable += letterForms['normal'];
                        }
                        return;
                    }
                    // console.log('keeping this letter');
                    returnable += letter;
                    return;
                }
                else if (typeof localVersion === 'object' && localVersion.indexOf && localVersion.indexOf(letter) > -1) {
                    // match
                    returnable += localVersion[0];
                    // console.log('added the first letter from the same array');
                    return;
                }
            }
        }
        // try ligatures
        for (var v2 = 0; v2 < reference_1.ligatureList.length; v2++) {
            var normalForm = reference_1.ligatureList[v2];
            if (normalForm !== 'words') {
                var ligForms = Object.keys(unicode_ligatures_1.default[normalForm]);
                for (var f = 0; f < ligForms.length; f++) {
                    if (unicode_ligatures_1.default[normalForm][ligForms[f]] === letter) {
                        returnable += normalForm;
                        return;
                    }
                }
            }
        }
        // try words ligatures
        for (var v3 = 0; v3 < reference_1.ligatureWordList.length; v3++) {
            var normalForm = reference_1.ligatureWordList[v3];
            if (unicode_ligatures_1.default.words[normalForm] === letter) {
                returnable += normalForm;
                return;
            }
        }
        returnable += letter;
        // console.log('kept the letter')
    });
    return returnable;
}
exports.Normal = Normal;
